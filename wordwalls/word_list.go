package wordwalls

// Interface with the django aerolith word list API.

type Question struct {
	Question string   `json:"q"`
	Answers  []string `json:"a"`
}

type WordList struct {
	ID int `json:"id"`

	Lexicon       string `json:"lexicon"`
	Temporary     bool   `json:"temporary"`
	QuestionIndex int    `json:"questionIndex"`

	NumCurAlphagrams int        `json:"numCurAlphagrams"`
	OrigQuestions    []Question `json:"origQuestions"`
	CurQuestions     []int      `json:"curQuestions"`
	NumQuestions     int        `json:"numAlphagrams"`
	Missed           []int      `json:"missed"`
	NumMissed        int        `json:"numMissed"`
	FirstMissed      []int      `json:"firstMissed"`
	NumFirstMissed   int        `json:"numFirstMissed"`

	Name         string `json:"name"`
	Version      int    `json:"version"`
	GoneThruOnce bool   `json:"goneThruOnce"`

	/*
	   This field is not strictly part of the word list, but it's the
	   current answer hash. It is generated by going through CurQuestions
	   (see generateAnswerHash)
	*/
	answerHash map[string]Answer
}

// Gets the next set of questions for this word list, and advances the
// pointer. Access to this word list is protected through the gamestates
// holder structure, so we don't need a mutex here.
func (w *WordList) nextSet(numQuestions int) []Question {
	qmin := w.QuestionIndex
	qmax := w.QuestionIndex + numQuestions
	questions := w.CurQuestions[qmin:qmax]
	w.QuestionIndex += numQuestions
	return w.generateQuestions(questions)
}

// Generate a set of Questions from the given questionIndices.
func (w *WordList) generateQuestions(questionIndices []int) []Question {
	questions := make([]Question, len(questionIndices))
	for i, qidx := range questionIndices {
		questions[i] = w.OrigQuestions[qidx]
	}
	w.generateAnswerHash(questions)
	return questions
}

// Generate answer hash and save it directly to w.answerHashes.
func (w *WordList) generateAnswerHash(questions []Question) {
	w.answerHash = make(map[string]Answer)
	for qidx, q := range questions {
		for _, word := range q.Answers {
			answer := Answer{Alphagram: q.Question, Idx: qidx}
			w.answerHash[word] = answer
		}
	}
}

// Save progress in this word list.
func (w *WordList) saveProgress(wc WebolithCommunicator) {
	syncWordList(wc, w)
}
